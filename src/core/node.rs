//! Repräsentiert einen einzelnen Wegpunkt im AutoDrive-Netzwerk.

use glam::Vec2;

/// Typ des Wegpunkts (Flags aus AutoDrive-Mod: FLAG_REGULAR, FLAG_SUBPRIO, etc.)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NodeFlag {
    /// Normaler Wegpunkt – mindestens ein Hauptstraßenanschluss
    Regular = 0,
    /// Nebenstraße (SubPrio) – nur Nebenstraßen münden in diesen Node
    SubPrio = 1,
    /// Auto-generiert (nur beim Import, wird zu Regular konvertiert)
    AutoGenerated = 2,
    /// Reserviert
    Reserved = 3,
    /// Spline-generiert (nur beim Import, wird zu Regular konvertiert)
    SplineGenerated = 4,
    /// Warnung
    Warning = 5,
}

impl NodeFlag {
    /// Konvertiert eine Zahl in den entsprechenden Flag-Typ.
    /// Bereinigt automatisch Flags 2 und 4 zu 0 (AutoGenerated/SplineGenerated aus älteren Versionen).
    pub fn from_u32(value: u32) -> Self {
        match value {
            1 => NodeFlag::SubPrio,
            2 | 4 => NodeFlag::Regular, // Auto-Bereinigung
            3 => NodeFlag::Reserved,
            5 => NodeFlag::Warning,
            _ => NodeFlag::Regular,
        }
    }

    /// Gibt den numerischen Flag-Wert zurueck
    pub fn to_u32(self) -> u32 {
        match self {
            NodeFlag::Regular => 0,
            NodeFlag::SubPrio => 1,
            NodeFlag::AutoGenerated => 2,
            NodeFlag::Reserved => 3,
            NodeFlag::SplineGenerated => 4,
            NodeFlag::Warning => 5,
        }
    }
}

/// Ein Wegpunkt im AutoDrive-Netzwerk
#[derive(Debug, Clone)]
pub struct MapNode {
    /// Eindeutige ID (vom User/AutoDrive vergeben)
    pub id: u64,
    /// Position in Welt-Koordinaten (2D)
    pub position: Vec2,
    /// Typ/Flag des Wegpunkts
    pub flag: NodeFlag,
}

impl MapNode {
    /// Erstellt einen neuen Wegpunkt
    pub fn new(id: u64, position: Vec2, flag: NodeFlag) -> Self {
        Self { id, position, flag }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_flag_conversion() {
        assert_eq!(NodeFlag::from_u32(0), NodeFlag::Regular);
        assert_eq!(NodeFlag::from_u32(1), NodeFlag::SubPrio);
        assert_eq!(NodeFlag::from_u32(2), NodeFlag::Regular); // Auto-Bereinigung
        assert_eq!(NodeFlag::from_u32(4), NodeFlag::Regular); // Auto-Bereinigung
        assert_eq!(NodeFlag::from_u32(5), NodeFlag::Warning);
    }
}
